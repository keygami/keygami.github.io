<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Keygami</title>
<style>
  :root{
    --bg:#0f1724;
    --panel:#0b1220;
    --blue:#1e90ff;
    --red:#ff4d4d;
    --cell-gap:2px;
  }
  html,body{height:100%;margin:0;background:var(--bg);display:flex;align-items:center;justify-content:center;font-family:Inter,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  #container{width:min(720px,95vw);aspect-ratio:12/20; background:linear-gradient(180deg,#071022 0%, #0c1626 100%);border-radius:12px;position:relative;overflow:hidden;box-shadow:0 10px 40px rgba(0,0,0,0.7);}
  #ui{
    position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:18px;z-index:10;pointer-events:auto;
    backdrop-filter: blur(2px);
  }
  .pills{display:flex;gap:18px;align-items:center}
  .pill{
    padding:16px 28px;border-radius:999px;font-weight:700;border:none;cursor:pointer;font-size:18px;min-width:140px;text-align:center;
    box-shadow:0 6px 18px rgba(0,0,0,0.4), inset 0 -2px rgba(0,0,0,0.15);
    transform:translateZ(0);
  }
  .pill.blue{background:var(--blue);color:white}
  .pill.red{background:var(--red);color:white}
  #message{color:#e6eef8;font-weight:600;text-align:center;font-size:20px;text-shadow:0 2px 6px rgba(0,0,0,0.6)}
  #scoreBoard{position:absolute;left:10px;top:10px;color:#cfe9ff;font-weight:700;z-index:9;padding:8px 12px;border-radius:8px;background:rgba(255,255,255,0.03);backdrop-filter: blur(2px)}
  canvas{width:100%;height:100%;display:block;background:transparent;image-rendering:pixelated}
  /* tiny control hint hidden per spec (no arrows explanation) */
  .small{font-size:12px;color:#9fb5d3}
</style>
</head>
<body>
  <div id="container" role="application" aria-label="Keygami game container">
    <div id="ui">
      <div id="message">Keygami</div>
      <div class="pills">
        <button id="btnBlue" class="pill blue">Red</button>
        <button id="btnRed" class="pill red">Blue</button>
      </div>
    </div>

    <div id="scoreBoard">Score: <span id="score">0</span> | Mode: <span id="mode">—</span></div>
    <canvas id="board" width="240" height="400"></canvas>
  </div>

<script>
/*
 Keygami - single-file implementation
 - Board: 12 cols x 20 rows (good compromise for Snake + Tetris)
 - Arrow keys used for controls, default scrolling prevented
 - Localization used from navigator.languages; first 3 launches show localized pill labels
 - Score switching, transformations, win at 100 points, Tetris-only loss
 - Comments in English
*/

// ====== Configuration ======
const COLS = 12;
const ROWS = 20;
const CELL = 20; // logical cell size for canvas; canvas size set accordingly
const WIN_SCORE = 100;
const INITIAL_LANG_SHOW = 3; // first three launches show localized labels

// Localization dictionary (supported languages)
const L10N = {
  en: {red: 'Red', blue: 'Blue', toContinue: 'To be continue ...', gameOver: 'Game over', keygami:'Keygami'},
  es: {red: 'Rojo', blue: 'Azul', toContinue: 'Continuará ...', gameOver: 'Fin del juego', keygami:'Keygami'},
  pt: {red: 'Vermelho', blue: 'Azul', toContinue: 'Continua...', gameOver: 'Fim de jogo', keygami:'Keygami'},
  ja: {red: '赤', blue: '青', toContinue: '続く...', gameOver: 'ゲームオーバー', keygami:'Keygami'},
  uk: {red: 'Червоний', blue: 'Синій', toContinue: 'Продовження слідує ...', gameOver: 'Гра завершена', keygami:'Keygami'},
  fr: {red: 'Rouge', blue: 'Bleu', toContinue: 'À suivre ...', gameOver: 'Jeu terminé', keygami:'Keygami'},
  it: {red: 'Rosso', blue: 'Blu', toContinue: 'Continua ...', gameOver: 'Fine del gioco', keygami:'Keygami'},
  tr: {red: 'Kırmızı', blue: 'Mavi', toContinue: 'Devam edecek ...', gameOver: 'Oyun bitti', keygami:'Keygami'}
};

// ====== DOM ======
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
canvas.width = COLS * CELL;
canvas.height = ROWS * CELL;

const ui = document.getElementById('ui');
const btnBlue = document.getElementById('btnBlue'); // visually blue but text "Red"
const btnRed = document.getElementById('btnRed');   // visually red but text "Blue"
const msg = document.getElementById('message');
const scoreSpan = document.getElementById('score');
const modeSpan = document.getElementById('mode');

let launches = parseInt(localStorage.getItem('keygami_launches') || '0', 10);

// ====== Helper: choose localization string based on navigator languages ======
function chooseLocale() {
  const langs = (navigator.languages && navigator.languages.length) ? navigator.languages : [navigator.language || 'en'];
  for (const l of langs) {
    const code = l.slice(0,2).toLowerCase();
    if (L10N[code]) return {code, dict: L10N[code]};
  }
  return {code:'en', dict:L10N.en};
}
const locale = chooseLocale();
function t(key){ return (locale.dict && locale.dict[key]) || L10N.en[key]; }

// Update pill labels depending on launch count
function updatePills() {
  if (launches < INITIAL_LANG_SHOW) {
    btnBlue.textContent = t('red'); // blue pill displays "Red" in locale
    btnRed.textContent = t('blue'); // red pill displays "Blue" in locale
    msg.textContent = t('keygami');
  } else {
    // After first 3 launches show English labels (or keep inverted English)
    btnBlue.textContent = L10N.en.red;
    btnRed.textContent = L10N.en.blue;
    msg.textContent = L10N.en.keygami;
  }
}
updatePills();

// ====== Input: prevent arrow keys from scrolling ======
window.addEventListener('keydown', (e) => {
  // prevent scrolling for arrow keys and space
  if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) {
    e.preventDefault();
  }
});
// Also capture keyup/down for game controls
const input = {left:false,right:false,up:false,down:false};
window.addEventListener('keydown',(e)=>{
  if (e.key === 'ArrowLeft') input.left = true;
  if (e.key === 'ArrowRight') input.right = true;
  if (e.key === 'ArrowUp') input.up = true;
  if (e.key === 'ArrowDown') input.down = true;
});
window.addEventListener('keyup',(e)=>{
  if (e.key === 'ArrowLeft') input.left = false;
  if (e.key === 'ArrowRight') input.right = false;
  if (e.key === 'ArrowUp') input.up = false;
  if (e.key === 'ArrowDown') input.down = false;
});

// ====== Game State ======
let state = {
  started: false,
  mode: null, // 'snake' or 'tetris'
  score: 0,
  switchThreshold: randomBetween(5,15),
  foodSpawnCounter: 0, // for red apple every 10
  launches // tracked
};

// update scoreboard display
function updateScoreBoard(){ scoreSpan.textContent = state.score; modeSpan.textContent = state.mode || '—'; }

// ====== Utility ======
function randomBetween(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

// ====== GRID: used by both games ======
function createGrid(rows, cols, fill=0){
  const g = new Array(rows);
  for(let r=0;r<rows;r++){ g[r] = new Array(cols).fill(fill); }
  return g;
}

// ====== SNAKE Implementation ======
const Snake = (() => {
  let snake = []; // array of {r,c}
  let dir = {r:0,c:1};
  let pendingDir = null;
  let food = null;
  let foodCount = 0;
  let tickTime = 120; // ms per move
  let lastTick = 0;
  let growBy = 0;

  function init() {
    // start snake near center
    snake = [{r: Math.floor(ROWS/2), c: Math.floor(COLS/2)},
             {r: Math.floor(ROWS/2), c: Math.floor(COLS/2)-1},
             {r: Math.floor(ROWS/2), c: Math.floor(COLS/2)-2}];
    dir = {r:0,c:1};
    pendingDir = null;
    growBy = 0;
    food = null;
    foodCount = 0;
    spawnFood();
  }

  function setDirectionFromInput() {
    // based on input flags, prefer last press: up/down before left/right pattern
    if (input.up && dir.r !== 1) pendingDir = {r:-1,c:0};
    if (input.down && dir.r !== -1) pendingDir = {r:1,c:0};
    if (input.left && dir.c !== 1) pendingDir = {r:0,c:-1};
    if (input.right && dir.c !== -1) pendingDir = {r:0,c:1};
  }

  function spawnFood(){
    // try random free cell
    foodCount++;
    const special = (foodCount % 10 === 0); // red apple once every 10 spawns
    for (let tries=0; tries<200; tries++){
      const r = Math.floor(Math.random()*ROWS);
      const c = Math.floor(Math.random()*COLS);
      // make sure not on snake
      if (!snake.some(s=>s.r===r && s.c===c)) {
        food = {r,c, special};
        return;
      }
    }
    // fallback: put at center
    food = {r: Math.floor(ROWS/2), c: Math.floor(COLS/2), special: special};
  }

  function tick(time) {
    if (!lastTick) lastTick = time;
    if (time - lastTick < tickTime) return false;
    lastTick = time;

    setDirectionFromInput();
    if (pendingDir) { dir = pendingDir; pendingDir = null; }

    // compute new head with edge wrapping
    const head = snake[0];
    let nr = head.r + dir.r;
    let nc = head.c + dir.c;
    if (nr < 0) nr = ROWS-1;
    if (nr >= ROWS) nr = 0;
    if (nc < 0) nc = COLS-1;
    if (nc >= COLS) nc = 0;

    // Insert new head
    snake.unshift({r:nr,c:nc});

    // Check food collision
    if (food && nr === food.r && nc === food.c) {
      // Eat food: increase score
      if (food.special) {
        state.score += 3; // red apple gives +3
      } else {
        state.score += 1;
      }
      updateScoreBoard();
      state.foodSpawnCounter++;
      growBy += (food.special ? 3 : 1);
      spawnFood();
    }

    // If not growing, remove tail
    if (growBy > 0) {
      growBy--;
    } else {
      snake.pop();
    }

    // Snake is invulnerable per spec (only Tetris loses). So no death on self-collision.
    return true;
  }

  function renderGrid(grid) {
    // draw snake onto grid as value 2
    for(const s of snake) {
      grid[s.r][s.c] = 2;
    }
    // draw food as 3 (special) or 4 (normal) to style differently
    if (food) grid[food.r][food.c] = (food.special ? 3 : 4);
  }

  function getSnakeSnapshot(){ return JSON.parse(JSON.stringify(snake)); }

  function setFromCells(cells) {
    // Take an array of {r,c} as new snake body; sort to make head first by arbitrary rule
    if (!cells || !cells.length) return;
    // To produce an ordered snake path, find a path through connected cells:
    // We'll pick one cell as head (lowest r then c), then greedily walk to neighbors
    const map = new Map(cells.map(p => [p.r+','+p.c, true]));
    const start = cells.reduce((a,b)=> (b.r<a.r || (b.r===a.r && b.c<a.c)) ? b : a, cells[0]);
    const path = [start];
    let cur = start;
    const dirs = [{r:1,c:0},{r:-1,c:0},{r:0,c:1},{r:0,c:-1}];
    while (path.length < cells.length) {
      let found = null;
      for (const d of dirs) {
        const nr = cur.r + d.r, nc = cur.c + d.c;
        if (map.has(nr+','+nc) && !path.some(p=>p.r===nr && p.c===nc)) { found = {r:nr,c:nc}; break; }
      }
      if (!found) break;
      path.push(found); cur = found;
    }
    snake = path;
  }

  return { init, tick, renderGrid, getSnakeSnapshot, setFromCells, spawnFood };
})();

// ====== TETRIS Implementation ======
const Tetris = (() => {
  // Playfield: rows x cols, 0 empty or a positive color index for blocks
  let grid = createGrid(ROWS, COLS, 0);
  // Tetromino shapes (4x4) rotated states simplified by rotation logic
  const TETROMINOS = {
    I: {cells:[[1,1,1,1]], color:1},
    O: {cells:[[1,1],[1,1]], color:2},
    T: {cells:[[0,1,0],[1,1,1]], color:3},
    S: {cells:[[0,1,1],[1,1,0]], color:4},
    Z: {cells:[[1,1,0],[0,1,1]], color:5},
    J: {cells:[[1,0,0],[1,1,1]], color:6},
    L: {cells:[[0,0,1],[1,1,1]], color:7}
  };
  const keys = Object.keys(TETROMINOS);
  let current = null; // {shape, r, c, cells, color}
  let dropInterval = 500; // ms
  let lastDrop = 0;
  let lockDelay = 200;
  let lastMove = 0;

  function reset() {
    grid = createGrid(ROWS, COLS, 0);
    current = null;
    dropInterval = 500;
    lastDrop = 0;
  }

  function spawnPieceFromShape(cells, color) {
    // cells is array of rows e.g. [[1,0],[1,1]]
    // spawn near top center; c is centered
    const w = cells[0].length;
    const r = 0;
    const c = Math.floor((COLS - w)/2);
    const piece = {cells: cells.map(row=>row.slice()), r, c, color: color || 1};
    // if collision immediately -> game over
    if (collides(piece, 0,0)) {
      return {ok:false, piece};
    }
    current = piece;
    return {ok:true, piece};
  }

  function spawnRandomPiece() {
    const key = keys[Math.floor(Math.random()*keys.length)];
    const base = TETROMINOS[key].cells;
    // deep clone and spawn
    spawnPieceFromShape(base.map(r=>r.slice()), TETROMINOS[key].color);
  }

  function collides(piece, dr, dc) {
    const {cells, r, c} = piece;
    for (let rr=0; rr<cells.length; rr++){
      for (let cc=0; cc<cells[0].length; cc++){
        if (!cells[rr][cc]) continue;
        const nr = r + rr + dr;
        const nc = c + cc + dc;
        if (nr < 0 || nc < 0 || nc >= COLS) return true;
        if (nr >= ROWS) return true;
        if (grid[nr][nc]) return true;
      }
    }
    return false;
  }

  function rotate(piece) {
    // rotate 90 deg clockwise
    const old = piece.cells;
    const h = old.length, w = old[0].length;
    const res = Array.from({length:w}, ()=> new Array(h).fill(0));
    for (let r=0;r<h;r++) for (let c=0;c<w;c++) res[c][h-1-r] = old[r][c];
    // adjust c if out of bounds
    const oldC = piece.c;
    piece.cells = res;
    if (piece.c + res[0].length > COLS) piece.c = COLS - res[0].length;
    if (collides(piece,0,0)) {
      // revert
      piece.cells = old;
      piece.c = oldC;
      return false;
    }
    return true;
  }

  function hardDrop() {
    if (!current) return;
    while(!collides(current,1,0)) current.r++;
    lockPiece();
  }

  function lockPiece() {
    // copy current into grid
    const {cells, r, c, color} = current;
    for (let rr=0; rr<cells.length; rr++){
      for (let cc=0; cc<cells[0].length; cc++){
        if (!cells[rr][cc]) continue;
        const nr = r + rr;
        const nc = c + cc;
        if (nr>=0 && nr<ROWS && nc>=0 && nc<COLS) grid[nr][nc] = color || 1;
      }
    }
    clearLines();
    current = null;
    // spawn next
    spawnRandomPiece();
  }

  function clearLines() {
    let linesCleared = 0;
    for (let r=ROWS-1; r>=0; r--) {
      if (grid[r].every(v=>v>0)) {
        grid.splice(r,1);
        grid.unshift(new Array(COLS).fill(0));
        linesCleared++;
        r++; // recheck same r index after splice
      }
    }
    if (linesCleared>0) {
      state.score += linesCleared; // 1 point per line
      updateScoreBoard();
    }
  }

  function tick(time) {
    if (!lastDrop) lastDrop = time;
    if (!current) { spawnRandomPiece(); lastDrop = time; return true; }

    // control movement from input (simple immediate response but with minimal delay)
    if (input.left && !collides(current,0,-1) && time - lastMove > 80) { current.c -= 1; lastMove = time;}
    if (input.right && !collides(current,0,1) && time - lastMove > 80) { current.c += 1; lastMove = time;}
    if (input.up && time - lastMove > 120) { rotate(current); lastMove = time; }
    if (input.down && time - lastMove > 80) {
      if (!collides(current,1,0)) { current.r += 1; lastMove = time; }
      else { lockPiece(); lastMove = time; }
    }

    if (time - lastDrop > dropInterval) {
      lastDrop = time;
      if (!collides(current,1,0)) {
        current.r += 1;
      } else {
        // lock
        lockPiece();
        // check game over condition: if top row has blocks (spawn collision would have been detected)
        for (let c=0;c<COLS;c++) {
          if (grid[0][c]) {
            // Tetris loss
            return 'lost';
          }
        }
      }
    }
    return true;
  }

  function renderGrid(outGrid) {
    // copy grid into outGrid: values >0 mark blocks
    for (let r=0;r<ROWS;r++){
      for (let c=0;c<COLS;c++){
        if (grid[r][c]) outGrid[r][c] = 10 + grid[r][c]; // differentiate tetris colors
      }
    }
    // render current piece
    if (current) {
      const {cells,r,c,color} = current;
      for (let rr=0; rr<cells.length; rr++){
        for (let cc=0; cc<cells[0].length; cc++){
          if (!cells[rr][cc]) continue;
          const nr = r+rr, nc = c+cc;
          if (nr>=0 && nr<ROWS && nc>=0 && nc<COLS) outGrid[nr][nc] = 10 + (color||1);
        }
      }
    }
  }

  function setGridFromSnakeShape(shapeCells) {
    // Place cells into top area as a falling piece that will be treated as current piece.
    // shapeCells: array of {r,c} relative to board (they come from snake)
    // We'll normalize into a compact 2D shape and spawn as a falling piece at top center.
    if (!shapeCells || !shapeCells.length) return false;
    // compute bounding rectangle
    let minR = Infinity, minC = Infinity, maxR=-Infinity, maxC=-Infinity;
    for (const p of shapeCells) { if (p.r<minR)minR=p.r; if (p.c<minC)minC=p.c; if (p.r>maxR)maxR=p.r; if (p.c>maxC)maxC=p.c; }
    const h = maxR-minR+1, w = maxC-minC+1;
    const cells = Array.from({length:h}, ()=> new Array(w).fill(0));
    for (const p of shapeCells) cells[p.r-minR][p.c-minC] = 1;
    // spawn piece at top center
    const spawnRes = spawnPieceFromShape(cells, 8); // choose color index 8
    if (!spawnRes.ok) {
      // if immediate collision, try reducing height or shift
      spawnRes.piece.r = 0;
    }
    return true;
  }

  // Expose some functions to transform existing grid into components
  function importGrid(g){
    grid = g.map(row=>row.slice());
  }

  function exportGrid(){ return grid.map(row=>row.slice()); }

  function longestConnectedComponent(){
    // Find longest orthogonally connected component in current grid
    const visited = createGrid(ROWS, COLS, 0);
    let best = [];
    for (let r=0;r<ROWS;r++){
      for (let c=0;c<COLS;c++){
        if (!grid[r][c] || visited[r][c]) continue;
        // BFS
        const q = [{r,c}], comp=[{r,c}]; visited[r][c]=1;
        while(q.length){
          const cur = q.shift();
          const dirs = [{r:1,c:0},{r:-1,c:0},{r:0,c:1},{r:0,c:-1}];
          for (const d of dirs){
            const nr = cur.r+d.r, nc = cur.c+d.c;
            if (nr<0||nr>=ROWS||nc<0||nc>=COLS) continue;
            if (!grid[nr][nc] || visited[nr][nc]) continue;
            visited[nr][nc]=1; q.push({r:nr,c:nc}); comp.push({r:nr,c:nc});
          }
        }
        if (comp.length > best.length) best = comp;
      }
    }
    return best;
  }

  return { reset, tick, renderGrid, importGrid, exportGrid, setGridFromSnakeShape, longestConnectedComponent };
})();

// ====== TRANSFORMATIONS BETWEEN MODES ======
function snakeToTetris() {
  // take snake snapshot -> form falling piece
  const snakeCells = Snake.getSnakeSnapshot();
  // clear everything from Tetris grid first
  Tetris.reset();
  // spawn piece based on snake cells
  Tetris.setGridFromSnakeShape(snakeCells);
  // switch mode
  state.mode = 'tetris';
  updateScoreBoard();
}

function tetrisToSnake() {
  // export tetris grid and compute longest connected component
  const gridCopy = Tetris.exportGrid();
  const comp = Tetris.longestConnectedComponent();
  // remove those comp cells from tetris grid (they will become snake)
  for (const p of comp) gridCopy[p.r][p.c] = 0;
  // Import remaining blocks back as static blocks (these become edible food for snake)
  Tetris.importGrid(gridCopy);
  // Set snake from comp
  Snake.setFromCells(comp);
  // switch mode
  state.mode = 'snake';
  updateScoreBoard();
}

// ====== Main flow: start and control ======
function startGame(startMode=null) {
  launches = (parseInt(localStorage.getItem('keygami_launches')||'0',10) || 0) + 1;
  localStorage.setItem('keygami_launches', String(launches));
  state.launches = launches;
  state.started = true;
  state.score = 0;
  state.switchThreshold = randomBetween(5,15);
  state.foodSpawnCounter = 0;
  updatePills(); // in case UI returns later
  // hide UI
  ui.style.display = 'none';
  // choose randomly snake or tetris (startMode overrides)
  const pick = startMode || (Math.random() < 0.5 ? 'snake' : 'tetris');
  state.mode = pick;
  updateScoreBoard();

  // init both engines
  Snake.init();
  Tetris.reset();

  if (state.mode === 'snake') {
    // snake starts
  } else {
    // tetris starts
  }

  // start animation loop
  lastFrame = performance.now();
  requestAnimationFrame(loop);
}

btnBlue.addEventListener('click', ()=> startGame());
btnRed.addEventListener('click', ()=> startGame());

// ====== Rendering ======
function clearCanvas(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // background
  ctx.fillStyle = '#07121b';
  ctx.fillRect(0,0,canvas.width,canvas.height);
}
function drawGrid(grid) {
  // draw cell-by-cell
  ctx.lineWidth = 0;
  for (let r=0;r<ROWS;r++){
    for (let c=0;c<COLS;c++){
      const v = grid[r][c];
      const x = c*CELL, y = r*CELL;
      if (!v) {
        // empty cell - subtle dark
        ctx.fillStyle = '#05101a';
        ctx.fillRect(x+1,y+1,CELL-2,CELL-2);
      } else {
        // color mapping: snake=2, tetris 10+index, food 3/4
        if (v === 2) ctx.fillStyle = '#7be08b'; // snake body
        else if (v === 3) ctx.fillStyle = '#ff5b5b'; // red apple
        else if (v === 4) ctx.fillStyle = '#ffd66b'; // normal food
        else if (v >= 11 && v <= 17) ctx.fillStyle = ['#000','#b3e5ff','#ffd6d6','#d1b0ff','#bff2d6','#ffd1b5','#ffe7a5','#bde0ff'][v-11] || '#9fb5d3';
        else if (v >= 10) ctx.fillStyle = '#8fb1ff';
        else ctx.fillStyle = '#9fb5d3';
        ctx.fillRect(x+1,y+1,CELL-2,CELL-2);
        // subtle highlight
        ctx.fillStyle = 'rgba(255,255,255,0.06)';
        ctx.fillRect(x+1,y+1,(CELL-2),2);
      }
    }
  }
}

// ====== Game Loop ======
let lastFrame = 0;
let running = true;
function loop(time) {
  if (!running) return;
  const dt = time - lastFrame;
  lastFrame = time;

  // Prepare empty render grid
  const renderGrid = createGrid(ROWS, COLS, 0);

  // Tick active mode
  if (state.mode === 'snake') {
    Snake.tick(time);
    // set snake and food into renderGrid
    Snake.renderGrid(renderGrid);
  } else if (state.mode === 'tetris') {
    const res = Tetris.tick(time);
    if (res === 'lost') {
      // Tetris loss -> show Game over
      endGame(false);
      return;
    }
    Tetris.renderGrid(renderGrid);
  }

  // Draw
  clearCanvas();
  drawGrid(renderGrid);

  // Check for switching condition
  if (state.score >= WIN_SCORE) {
    endGame(true);
    return;
  }

  if (state.score >= state.switchThreshold) {
    // perform transformation
    const prevMode = state.mode;
    // choose new threshold for next switch (so it can continue switching)
    state.switchThreshold += randomBetween(5,15);
    if (prevMode === 'snake') {
      // snake -> tetris: snake becomes falling shape
      snakeToTetris();
    } else {
      // tetris -> snake: choose longest component becomes snake
      tetrisToSnake();
    }
  }

  requestAnimationFrame(loop);
}

// ====== End & Restart ======
function showUIWithMessage(text) {
  msg.textContent = text;
  ui.style.display = 'flex';
  updatePills();
}

function endGame(win) {
  running = false;
  state.started = false;
  // show message localized
  if (win) {
    showUIWithMessage(t('toContinue') || L10N.en.toContinue);
  } else {
    showUIWithMessage(t('gameOver') || L10N.en.gameOver);
  }
  // show pills again (they are already visible in UI)
  // reset some things
  state.mode = null;
  updateScoreBoard();
  // allow restart via buttons; clicking will call startGame again
  // Make sure next start uses incremented launch count (already stored)
  // Reset running for next start
  running = true;
}

// ====== Initialization: small visual tweak for first display ======
updateScoreBoard();

// Extra: expose a debug start function (not shown) - left out per spec

// Accessibility: clicking inside canvas focuses it so arrow prevention works inline
canvas.addEventListener('click', ()=> canvas.focus());
</script>
</body>
</html>
