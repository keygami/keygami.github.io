<!doctype html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Keygami — Snake + Tetris</title>
  <style>
    :root{--bg:#0f1724;--panel:#0b1220;--accent:#0ea5e9;--danger:#ef4444;--text:#e6eef8}
    html,body{height:100%;margin:0;font-family:Inter, system-ui, Arial, sans-serif;background:linear-gradient(180deg,#071026 0%, #0b1220 100%);color:var(--text)}
    .wrap{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:20px}
    .card{width:960px;max-width:100%;background:rgba(255,255,255,0.02);border-radius:14px;padding:18px;box-shadow:0 8px 30px rgba(2,6,23,0.6)}
    .header{display:flex;align-items:center;gap:16px;margin-bottom:12px}
    h1{font-size:20px;margin:0}
    .controls{display:flex;gap:12px;align-items:center}
    .pill{padding:12px 18px;border-radius:999px;cursor:pointer;user-select:none;font-weight:600;display:inline-flex;align-items:center;justify-content:center;min-width:120px;box-shadow:0 6px 18px rgba(2,6,23,0.5)}
    .pill.blue{background:linear-gradient(180deg,#2b7bdc,#0b5fb8);color:white}
    .pill.red{background:linear-gradient(180deg,#f45a6a,#d32b2b);color:white}
    .pill:active{transform:translateY(1px)}
    .board-row{display:flex;gap:12px}
    .canvas-wrap{display:flex;gap:12px;align-items:flex-start}
    #gameCanvas{background:#071827;border-radius:8px;border:1px solid rgba(255,255,255,0.03)}
    .info{flex:1;min-width:240px}
    .small{font-size:12px;color:rgba(230,238,248,0.7)}
    .big-score{font-size:28px;margin:12px 0}
    .center{display:flex;align-items:center;justify-content:center}
    .hidden{display:none}
    .footer{margin-top:12px;font-size:13px;color:rgba(230,238,248,0.6)}
    .btn-ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 12px;border-radius:8px;color:var(--text);cursor:pointer}
    /* responsive */
    @media (max-width:720px){.card{padding:12px}.header{flex-direction:column;align-items:flex-start}.canvas-wrap{flex-direction:column}.info{min-width:unset}}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="header">
        <div>
          <h1>Keygami — Snake + Tetris</h1>
          <div class="small">Керуйте стрілками. Стрілки не прокручують сторінку під час гри.</div>
        </div>
        <div style="flex:1"></div>
        <div class="controls" id="startControls">
          <div id="blueBtn" class="pill blue">Червона</div>
          <div id="redBtn" class="pill red">Синя</div>
        </div>
      </div>

      <div class="canvas-wrap">
        <canvas id="gameCanvas" width="480" height="640"></canvas>
        <div class="info">
          <div class="big-score">Score: <span id="score">0</span></div>
          <div class="small">Mode: <span id="modeLabel">—</span></div>
          <div class="small">Transform at: <span id="transformAt">—</span></div>
          <div style="height:12px"></div>
          <div id="message" class="small"></div>
          <div style="height:18px"></div>
          <div>
            <button id="restartBtn" class="btn-ghost hidden">Restart</button>
            <button id="backToStart" class="btn-ghost hidden">Back to start</button>
          </div>
          <div class="footer">Мова сесії: <span id="sessLang">—</span></div>
        </div>
      </div>
    </div>
  </div>

  <script>
  // Keygami — single-file game

  (function(){
    // Languages
    const supported = ['en','es','pt','ja','uk','fr','it','tr'];
    const labels = {
      en:{red:'Red', blue:'Blue', tobe:'To be continue ...', over:'Game over'},
      es:{red:'Rojo', blue:'Azul', tobe:'Continuará ...', over:'Juego terminado'},
      pt:{red:'Vermelho', blue:'Azul', tobe:'Continua ...', over:'Fim de jogo'},
      ja:{red:'赤', blue:'青', tobe:'つづく ...', over:'ゲームオーバー'},
      uk:{red:'Червона', blue:'Синя', tobe:'To be continue ...', over:'Game over'},
      fr:{red:'Rouge', blue:'Bleu', tobe:'Suite à venir ...', over:'Partie terminée'},
      it:{red:'Rosso', blue:'Blu', tobe:'Continua ...', over:'Game over'},
      tr:{red:'Kırmızı', blue:'Mavi', tobe:'Devam edecek ...', over:'Oyun bitti'}
    };

    const blueBtn = document.getElementById('blueBtn');
    const redBtn = document.getElementById('redBtn');
    const startControls = document.getElementById('startControls');
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const modeLabel = document.getElementById('modeLabel');
    const transformAtEl = document.getElementById('transformAt');
    const messageEl = document.getElementById('message');
    const restartBtn = document.getElementById('restartBtn');
    const backToStart = document.getElementById('backToStart');
    const sessLangEl = document.getElementById('sessLang');

    // Launch count logic
    let launches = parseInt(localStorage.getItem('keygami_launch_count')||'0',10);
    let sessionLang = sessionStorage.getItem('keygami_session_lang')||null;

    function pickInitialLanguage(){
      if(!sessionLang){
        // first three launches => use browser Accept-Language primary if supported
        const accept = (navigator.languages && navigator.languages.length)? navigator.languages : [navigator.language || 'en'];
        let pick = 'en';
        for(const a of accept){
          const code = a.split('-')[0];
          if(supported.includes(code)){ pick = code; break; }
        }
        if(launches < 3){ sessionLang = pick; }
        else { sessionLang = supported[Math.floor(Math.random()*supported.length)]; }
        sessionStorage.setItem('keygami_session_lang', sessionLang);
      }
      sessLangEl.textContent = sessionLang;
    }

    function updatePillsText(){
      // Blue pill must show text meaning RED, red pill shows BLUE
      const lang = sessionLang || 'en';
      blueBtn.textContent = labels[lang].red;
      redBtn.textContent = labels[lang].blue;
    }

    pickInitialLanguage();
    updatePillsText();

    // Game state
    let game=null; // 'snake'|'tetris'
    let score=0;
    let transformAt = randInt(5,15);
    let running=false;
    let rafId=null;
    let inputDir=null; // -1 left,1 right,0 none, up/down for snake

    transformAtEl.textContent = transformAt;
    scoreEl.textContent = score;

    // Utility
    function randInt(a,b){return Math.floor(Math.random()*(b-a+1))+a}

    // Prevent arrow keys scrolling while playing
    window.addEventListener('keydown', (e)=>{
      if(running && ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)){
        e.preventDefault();
      }
    },{passive:false});

    // Button handlers
    function startRandom(selectedColor){
      // selectedColor is 'blue' or 'red' but we ignore; start random game
      launches += 1; localStorage.setItem('keygami_launch_count', String(launches));
      // possibly pick new session language for next starts (behavior specified: for first 3 runs use browser language; at next starts language will be random from list)
      if(launches>=3){ // after bump, future starts should use random -> clear session storage so pickInitialLanguage will pick random
        sessionStorage.removeItem('keygami_session_lang');
      }

      pickInitialLanguage();
      updatePillsText();
      transformAt = randInt(5,15);
      transformAtEl.textContent = transformAt;
      score = 0; scoreEl.textContent = score;
      messageEl.textContent = '';
      startControls.classList.add('hidden');
      restartBtn.classList.add('hidden');
      backToStart.classList.add('hidden');

      // choose game at random
      game = Math.random()<0.5? 'snake' : 'tetris';
      modeLabel.textContent = game;
      running = true;

      if(game==='snake'){ initSnake(); }
      else { initTetris(); }

      loop();
    }

    blueBtn.addEventListener('click', ()=>startRandom('blue'));
    redBtn.addEventListener('click', ()=>startRandom('red'));

    restartBtn.addEventListener('click', ()=>{
      // restart same session language
      sessionStorage.setItem('keygami_session_lang', sessionLang);
      startRandom();
    });
    backToStart.addEventListener('click', ()=>{
      stopGame();
      startControls.classList.remove('hidden');
      restartBtn.classList.add('hidden');
      backToStart.classList.add('hidden');
    });

    // --- SNAKE implementation ---
    const S = {cols:12, rows:16, cell:32};
    let snake=null; let food=null; let snakeTick=0; let snakeSpeed=8;

    function initSnake(){
      // set canvas size according to S
      canvas.width = S.cols * S.cell; canvas.height = S.rows * S.cell;
      snake = {dir:{x:1,y:0}, body:[{x:2,y:8},{x:1,y:8},{x:0,y:8}]};
      food = randomFood();
      snakeTick = 0; snakeSpeed = 8;
      window.addEventListener('keydown', snakeKey);
    }
    function snakeKey(e){
      if(!running || game!=='snake') return;
      if(e.key==='ArrowUp' && snake.dir.y!==1) snake.dir={x:0,y:-1};
      if(e.key==='ArrowDown' && snake.dir.y!==-1) snake.dir={x:0,y:1};
      if(e.key==='ArrowLeft' && snake.dir.x!==1) snake.dir={x:-1,y:0};
      if(e.key==='ArrowRight' && snake.dir.x!==-1) snake.dir={x:1,y:0};
    }
    function randomFood(){
      while(true){
        const p={x:randInt(0,S.cols-1),y:randInt(0,S.rows-1)};
        if(!snake.body.some(s=>s.x===p.x && s.y===p.y)) return p;
      }
    }
    function updateSnake(){
      snakeTick++;
      if(snakeTick < snakeSpeed) return;
      snakeTick=0;
      const head = {x:snake.body[0].x+snake.dir.x, y:snake.body[0].y+snake.dir.y};
      // wrap
      if(head.x<0) head.x=S.cols-1; if(head.x>=S.cols) head.x=0;
      if(head.y<0) head.y=S.rows-1; if(head.y>=S.rows) head.y=0;
      // collision with itself
      if(snake.body.some((b,i)=>i>0 && b.x===head.x && b.y===head.y)){
        endGame(false); return;
      }
      snake.body.unshift(head);
      if(head.x===food.x && head.y===food.y){
        score += 1; scoreEl.textContent = score; food = randomFood();
        // speed up occasionally
        if(score%5===0 && snakeSpeed>3) snakeSpeed--;
      } else {
        snake.body.pop();
      }

      if(score>=transformAt){ transformSnakeToTetris(); }
      if(score>=100){ endGame(true); }
    }
    function drawSnake(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // grid background
      ctx.fillStyle='#051016'; ctx.fillRect(0,0,canvas.width,canvas.height);
      // food
      drawCell(food.x, food.y, '#ffcc00');
      // snake
      for(let i=0;i<snake.body.length;i++){
        const s=snake.body[i];
        drawCell(s.x,s.y,i===0? '#66ff66':'#2fd36a');
      }
    }

    function drawCell(cx,cy,color){
      ctx.fillStyle = color; ctx.fillRect(cx*S.cell+1, cy*S.cell+1, S.cell-2, S.cell-2);
    }

    function transformSnakeToTetris(){
      // create a falling piece shaped from the snake head + next segments (max 4 blocks)
      const len = Math.min(4, snake.body.length);
      const piece = [];
      for(let i=0;i<len;i++){
        piece.push({x:snake.body[i].x, y:snake.body[i].y});
      }
      // stop snake listeners
      window.removeEventListener('keydown', snakeKey);
      // initialize tetris but with custom starting falling piece
      initTetris(piece);
      game='tetris'; modeLabel.textContent = game;
    }

    // --- TETRIS implementation ---
    const T = {cols:10, rows:20, cell:32};
    let grid=null; let currentPiece=null; let dropTick=0; let dropSpeed=30; let tetrisTick=0;

    const tetrominoes = [
      {name:'I', blocks:[[0,0],[1,0],[2,0],[3,0]]},
      {name:'O', blocks:[[0,0],[1,0],[0,1],[1,1]]},
      {name:'T', blocks:[[1,0],[0,1],[1,1],[2,1]]},
      {name:'L', blocks:[[0,0],[0,1],[0,2],[1,2]]},
      {name:'J', blocks:[[1,0],[1,1],[1,2],[0,2]]},
      {name:'S', blocks:[[1,0],[2,0],[0,1],[1,1]]},
      {name:'Z', blocks:[[0,0],[1,0],[1,1],[2,1]]},
    ];

    function initTetris(customPiece){
      // Adapt canvas
      canvas.width = T.cols * T.cell; canvas.height = T.rows * T.cell;
      grid = Array.from({length:T.rows}, ()=>Array(T.cols).fill(0));
      // fill with zero
      if(customPiece){
        // Place piece near top center by translating positions relative to miny
        const minx = Math.min(...customPiece.map(p=>p.x));
        const miny = Math.min(...customPiece.map(p=>p.y));
        // normalize and create piece blocks
        const blocks = customPiece.map(p=>[p.x-minx, p.y-miny]);
        currentPiece = {blocks, x:Math.floor(T.cols/2)-1, y:0, color:'#66ccff'};
      } else {
        spawnRandomPiece();
      }
      dropTick=0; dropSpeed = 30; tetrisTick=0;
      window.addEventListener('keydown', tetrisKey);
    }

    function spawnRandomPiece(){
      const p = tetrominoes[Math.floor(Math.random()*tetrominoes.length)];
      const blocks = p.blocks.map(b=>[b[0], b[1]]);
      currentPiece = {blocks, x:Math.floor(T.cols/2)-1, y:0, color:randomColor()};
    }
    function randomColor(){ return ['#66ff66','#66ccff','#ffcc66','#ff88cc','#cc88ff','#88ffcc'][Math.floor(Math.random()*6)]; }

    function rotateBlocks(blocks){
      // rotate about origin
      return blocks.map(([x,y])=>[-y,x]);
    }
    function canPlace(blocks, x, y){
      for(const b of blocks){
        const bx = x + b[0], by = y + b[1];
        if(bx<0||bx>=T.cols||by<0||by>=T.rows) return false;
        if(grid[by][bx]) return false;
      }
      return true;
    }
    function lockPiece(){
      for(const b of currentPiece.blocks){
        const bx = currentPiece.x + b[0]; const by = currentPiece.y + b[1];
        if(by<0){ endGame(false); return; }
        grid[by][bx] = currentPiece.color;
      }
      clearLines();
      // after locking, maybe check transform condition
      spawnRandomPiece();
    }
    function clearLines(){
      let cleared=0;
      for(let r=T.rows-1;r>=0;r--){
        if(grid[r].every(c=>c!==0)){
          grid.splice(r,1); grid.unshift(Array(T.cols).fill(0)); cleared++; r++;
        }
      }
      if(cleared>0){ score += cleared*2; scoreEl.textContent = score; }
      // check transform
      if(score>=transformAt){ transformTetrisToSnake(); }
      if(score>=100){ endGame(true); }
    }

    function tetrisKey(e){
      if(!running || game!=='tetris') return;
      if(e.key==='ArrowLeft'){ if(canPlace(currentPiece.blocks, currentPiece.x-1, currentPiece.y)) currentPiece.x--; }
      if(e.key==='ArrowRight'){ if(canPlace(currentPiece.blocks, currentPiece.x+1, currentPiece.y)) currentPiece.x++; }
      if(e.key==='ArrowUp'){ const nb = rotateBlocks(currentPiece.blocks); if(canPlace(nb,currentPiece.x,currentPiece.y)) currentPiece.blocks = nb; }
      if(e.key==='ArrowDown'){ // soft drop
        if(canPlace(currentPiece.blocks,currentPiece.x,currentPiece.y+1)) currentPiece.y++;
      }
      if(e.key===' '){ // hard drop
        while(canPlace(currentPiece.blocks,currentPiece.x,currentPiece.y+1)) currentPiece.y++; lockPiece(); }
    }

    function updateTetris(){
      dropTick++;
      if(dropTick < dropSpeed) return;
      dropTick=0;
      if(canPlace(currentPiece.blocks,currentPiece.x,currentPiece.y+1)){
        currentPiece.y++;
      } else {
        lockPiece();
      }
    }

    function drawTetris(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // bg
      ctx.fillStyle='#051016'; ctx.fillRect(0,0,canvas.width,canvas.height);
      // draw grid blocks
      for(let r=0;r<T.rows;r++){
        for(let c=0;c<T.cols;c++){
          if(grid[r][c]){
            ctx.fillStyle = grid[r][c]; ctx.fillRect(c*T.cell+1, r*T.cell+1, T.cell-2, T.cell-2);
          }
        }
      }
      // draw current piece
      if(currentPiece){
        ctx.fillStyle = currentPiece.color;
        for(const b of currentPiece.blocks){
          const x = currentPiece.x + b[0]; const y = currentPiece.y + b[1];
          ctx.fillRect(x*T.cell+1, y*T.cell+1, T.cell-2, T.cell-2);
        }
      }
    }

    function transformTetrisToSnake(){
      // find largest connected component of filled blocks
      const visited = Array.from({length:T.rows}, ()=>Array(T.cols).fill(false));
      let best = [];
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      for(let r=0;r<T.rows;r++){
        for(let c=0;c<T.cols;c++){
          if(grid[r][c] && !visited[r][c]){
            // bfs
            const q = [[r,c]]; visited[r][c]=true; let comp = [[c,r]];
            while(q.length){
              const [rr,cc] = q.shift();
              for(const d of dirs){ const nr=rr+d[1], nc=cc+d[0]; if(nr>=0&&nr<T.rows&&nc>=0&&nc<T.cols && !visited[nr][nc] && grid[nr][nc]){ visited[nr][nc]=true; q.push([nr,nc]); comp.push([nc,nr]); } }
            }
            if(comp.length>best.length) best=comp;
          }
        }
      }
      if(best.length===0){ return; }
      // remove best from grid
      for(const [cx,cy] of best){ grid[cy][cx]=0; }
      // create snake segments from best coords, translate to small board S
      // Place snake in middle top
      snake = {dir:{x:1,y:0}, body:[]};
      // sort by y then x
      best.sort((a,b)=>a[1]-b[1] || a[0]-b[0]);
      for(const [cx,cy] of best.slice(0, Math.min(50, best.length))){ // limit
        // scale positions to S grid
        const nx = Math.floor((cx / (T.cols-1 || 1)) * (S.cols-1));
        const ny = Math.floor((cy / (T.rows-1 || 1)) * (S.rows-1));
        snake.body.push({x:nx,y:ny});
      }
      if(snake.body.length===0) snake.body = [{x:2,y:8},{x:1,y:8},{x:0,y:8}];
      food = randomFood();
      // detach tetris handlers
      window.removeEventListener('keydown', tetrisKey);
      game='snake'; modeLabel.textContent = game;
    }

    // Main loop
    function loop(){
      if(!running) return;
      rafId = requestAnimationFrame(loop);
      if(game==='snake'){
        updateSnake(); drawSnake();
      } else if(game==='tetris'){
        updateTetris(); drawTetris();
      }
    }

    function stopGame(){
      running=false; cancelAnimationFrame(rafId);
      try{ window.removeEventListener('keydown', snakeKey); window.removeEventListener('keydown', tetrisKey);}catch(e){}
    }

    function endGame(win){
      stopGame();
      const lang = sessionLang || 'en';
      messageEl.textContent = win? labels[lang].tobe : labels[lang].over;
      restartBtn.classList.remove('hidden'); backToStart.classList.remove('hidden');
      startControls.classList.add('hidden');
    }

    // ensure page doesn't scroll on arrow keys when clicking canvas
    canvas.addEventListener('keydown', (e)=>{ if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) e.preventDefault(); });
    canvas.tabIndex = 0;

    // small safeguard: if user resizes, redraw UI
    window.addEventListener('resize', ()=>{
      if(game==='snake') drawSnake(); else if(game==='tetris') drawTetris();
    });

    // initial draw
    ctx.fillStyle='#051016'; ctx.fillRect(0,0,canvas.width,canvas.height);

  })();

  </script>
</body>
</html>
